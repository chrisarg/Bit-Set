/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.60 from the
 * contents of Set.xs. Do not edit this file, edit Set.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Set.xs"
#include "macros_defs.h"
#line 12 "Set.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%" UVxf ")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#define croak_xs_usage        S_croak_xs_usage

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#if PERL_VERSION_LE(5, 21, 5)
#  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
#else
#  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
#endif

/* simple backcompat versions of the TARGx() macros with no optimisation */
#ifndef TARGi
#  define TARGi(iv, do_taint) sv_setiv_mg(TARG, iv)
#  define TARGu(uv, do_taint) sv_setuv_mg(TARG, uv)
#  define TARGn(nv, do_taint) sv_setnv_mg(TARG, nv)
#endif

#line 163 "Set.c"

/* INCLUDE:  Including 'Set_procedural.xs' from 'Set.xs' */

#include "macros_defs.h"


XS_EUPXS(XS_Bit__Set_Bit_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_Bit_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "length");
    {
	SV *	RETVAL;
	IV	length = (IV)SvIV(ST(0))
;
#line 9 "./Set_procedural.xs"
        Bit_T set = Bit_new((int)length);
        RETVAL = newSVuv(PTR2UV(set));
#line 183 "Set.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bit__Set_Bit_free); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_Bit_free)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "set_ref");
    {
	SV *	set_ref = ST(0)
;
#line 17 "./Set_procedural.xs"
        if (!SvROK(set_ref)) {
            croak("Bit_free expects a scalar reference");
        }
        SV *inner = SvRV(set_ref);
        Bit_T set = INT2PTR(Bit_T, SvIV(inner));
        Bit_free(&set);
#line 207 "Set.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bit__Set_Bit_load); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_Bit_load)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "length, buffer");
    {
	SV *	RETVAL;
	IV	length = (IV)SvIV(ST(0))
;
	SV *	buffer = ST(1)
;
#line 28 "./Set_procedural.xs"
        void *ptr = SV_TO_VOID(buffer);
        Bit_T set = Bit_load((int)length, ptr);
        RETVAL = newSVuv(PTR2UV(set));
#line 229 "Set.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bit__Set_Bit_extract); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_Bit_extract)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "set, buffer");
    {
	IV	RETVAL;
	dXSTARG;
	SV *	set = ST(0)
;
	SV *	buffer = ST(1)
;
#line 37 "./Set_procedural.xs"
        Bit_T obj = SV_TO_BIT_T(Bit_T, set, UNDEF_ERROR);
        void *ptr = SV_TO_VOID(buffer);
        RETVAL = (IV)Bit_extract(obj, ptr);
#line 254 "Set.c"
	TARGi((IV)RETVAL, 1);
	ST(0) = TARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bit__Set_Bit_buffer_size); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_Bit_buffer_size)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "length");
    {
	IV	RETVAL;
	dXSTARG;
	IV	length = (IV)SvIV(ST(0))
;
#line 46 "./Set_procedural.xs"
        RETVAL = (IV)Bit_buffer_size((int)length);
#line 275 "Set.c"
	TARGi((IV)RETVAL, 1);
	ST(0) = TARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bit__Set_Bit_length); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_Bit_length)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "set");
    {
	IV	RETVAL;
	dXSTARG;
	SV *	set = ST(0)
;
#line 53 "./Set_procedural.xs"
        Bit_T obj = SV_TO_BIT_T(Bit_T, set, UNDEF_ERROR);
        RETVAL = (IV)Bit_length(obj);
#line 297 "Set.c"
	TARGi((IV)RETVAL, 1);
	ST(0) = TARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bit__Set_Bit_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_Bit_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "set");
    {
	IV	RETVAL;
	dXSTARG;
	SV *	set = ST(0)
;
#line 61 "./Set_procedural.xs"
        Bit_T obj = SV_TO_BIT_T(Bit_T, set, UNDEF_ERROR);
        RETVAL = (IV)Bit_count(obj);
#line 319 "Set.c"
	TARGi((IV)RETVAL, 1);
	ST(0) = TARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bit__Set_Bit_aset); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_Bit_aset)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "set, indices");
    {
	SV *	set = ST(0)
;
	INTEGER_ARRAY_REF	indices;

	if (!SvOK(ST(1)) || !SvROK(ST(1)))
		croak(UNDEF_NON_REF_ARRAY_ERROR);
	if (SvTYPE(SvRV(ST(1))) != SVt_PVAV)
		croak("indices should be an array reference");
	indices = ST(1)
;
#line 69 "./Set_procedural.xs"
        Bit_T obj = SV_TO_BIT_T(Bit_T, set, UNDEF_ERROR);
        int stack_buf[STACK_MAX];
        int *idx=NULL;
        AV *av = (AV *)SvRV(indices);
        int n = av_len(av) + 1;
        if(n <=STACK_MAX) {
            idx =stack_buf;
        } else {
            Newx(idx, n,int );  // no need to handle null here, C will handle it
        }
        for (int i = 0; i < n; ++i) {
            SV **svp = av_fetch(av, i, 0);
            idx[i] = SvIV(*svp);
        }

        Bit_aset(obj, idx, n);

        if (idx != stack_buf)
            Safefree(idx);
#line 364 "Set.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bit__Set_Bit_bset); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_Bit_bset)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "set, index");
    {
	SV *	set = ST(0)
;
	IV	index = (IV)SvIV(ST(1))
;
#line 92 "./Set_procedural.xs"
        Bit_T obj = SV_TO_BIT_T(Bit_T, set, UNDEF_ERROR);
        Bit_bset(obj, (int)index);
#line 384 "Set.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bit__Set_Bit_aclear); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_Bit_aclear)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "set, indices");
    {
	SV *	set = ST(0)
;
	INTEGER_ARRAY_REF	indices;

	if (!SvOK(ST(1)) || !SvROK(ST(1)))
		croak(UNDEF_NON_REF_ARRAY_ERROR);
	if (SvTYPE(SvRV(ST(1))) != SVt_PVAV)
		croak("indices should be an array reference");
	indices = ST(1)
;
#line 98 "./Set_procedural.xs"
        Bit_T obj = SV_TO_BIT_T(Bit_T, set, UNDEF_ERROR);
        int stack_buf[STACK_MAX];
        int *idx=NULL;
        AV *av = (AV *)SvRV(indices);
        int n = av_len(av) + 1;
        if(n <=STACK_MAX) {
            idx =stack_buf;
        } else {
            Newx(idx, n,int );  // no need to handle null here, C will handle it
        }
        for (int i = 0; i < n; ++i) {
            SV **svp = av_fetch(av, i, 0);
            idx[i] = SvIV(*svp);
        }

        Bit_aclear(obj, idx, n);

        if (idx != stack_buf)
            Safefree(idx);
#line 427 "Set.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bit__Set_Bit_bclear); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_Bit_bclear)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "set, index");
    {
	SV *	set = ST(0)
;
	IV	index = (IV)SvIV(ST(1))
;
#line 121 "./Set_procedural.xs"
        Bit_T obj = SV_TO_BIT_T(Bit_T, set, UNDEF_ERROR);
        Bit_bclear(obj, (int)index);
#line 447 "Set.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bit__Set_Bit_clear); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_Bit_clear)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "set, lo, hi");
    {
	SV *	set = ST(0)
;
	IV	lo = (IV)SvIV(ST(1))
;
	IV	hi = (IV)SvIV(ST(2))
;
#line 127 "./Set_procedural.xs"
        Bit_T obj = SV_TO_BIT_T(Bit_T, set, UNDEF_ERROR);
        Bit_clear(obj, (int)lo, (int)hi);
#line 469 "Set.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bit__Set_Bit_get); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_Bit_get)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "set, index");
    {
	IV	RETVAL;
	dXSTARG;
	SV *	set = ST(0)
;
	IV	index = (IV)SvIV(ST(1))
;
#line 133 "./Set_procedural.xs"
        Bit_T obj = SV_TO_BIT_T(Bit_T, set, UNDEF_ERROR);
        RETVAL = (IV)Bit_get(obj, (int)index);
#line 491 "Set.c"
	TARGi((IV)RETVAL, 1);
	ST(0) = TARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bit__Set_Bit_not); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_Bit_not)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "set, lo, hi");
    {
	SV *	set = ST(0)
;
	IV	lo = (IV)SvIV(ST(1))
;
	IV	hi = (IV)SvIV(ST(2))
;
#line 141 "./Set_procedural.xs"
        Bit_T obj = SV_TO_BIT_T(Bit_T, set, UNDEF_ERROR);
        Bit_not(obj, (int)lo, (int)hi);
#line 515 "Set.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bit__Set_Bit_put); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_Bit_put)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "set, n, val");
    {
	IV	RETVAL;
	dXSTARG;
	SV *	set = ST(0)
;
	IV	n = (IV)SvIV(ST(1))
;
	IV	val = (IV)SvIV(ST(2))
;
#line 147 "./Set_procedural.xs"
        Bit_T obj = SV_TO_BIT_T(Bit_T, set, UNDEF_ERROR);
        RETVAL = (IV)Bit_put(obj, (int)n, (int)val);
#line 539 "Set.c"
	TARGi((IV)RETVAL, 1);
	ST(0) = TARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bit__Set_Bit_set); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_Bit_set)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "set, lo, hi");
    {
	SV *	set = ST(0)
;
	IV	lo = (IV)SvIV(ST(1))
;
	IV	hi = (IV)SvIV(ST(2))
;
#line 155 "./Set_procedural.xs"
        Bit_T obj = SV_TO_BIT_T(Bit_T, set, UNDEF_ERROR);
        Bit_set(obj, (int)lo, (int)hi);
#line 563 "Set.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bit__Set_Bit_eq); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_Bit_eq)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "s, t");
    {
	IV	RETVAL;
	dXSTARG;
	SV *	s = ST(0)
;
	SV *	t = ST(1)
;
#line 161 "./Set_procedural.xs"
        Bit_T ss = SV_TO_BIT_T(Bit_T, s, UNDEF_ERROR);
        Bit_T tt = SV_TO_BIT_T(Bit_T, t, UNDEF_ERROR);
        RETVAL = (IV)Bit_eq(ss, tt);
#line 586 "Set.c"
	TARGi((IV)RETVAL, 1);
	ST(0) = TARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bit__Set_Bit_leq); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_Bit_leq)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "s, t");
    {
	IV	RETVAL;
	dXSTARG;
	SV *	s = ST(0)
;
	SV *	t = ST(1)
;
#line 170 "./Set_procedural.xs"
        Bit_T ss = SV_TO_BIT_T(Bit_T, s, UNDEF_ERROR);
        Bit_T tt = SV_TO_BIT_T(Bit_T, t, UNDEF_ERROR);
        RETVAL = (IV)Bit_leq(ss, tt);
#line 611 "Set.c"
	TARGi((IV)RETVAL, 1);
	ST(0) = TARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bit__Set_Bit_lt); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_Bit_lt)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "s, t");
    {
	IV	RETVAL;
	dXSTARG;
	SV *	s = ST(0)
;
	SV *	t = ST(1)
;
#line 179 "./Set_procedural.xs"
        Bit_T ss = SV_TO_BIT_T(Bit_T, s, UNDEF_ERROR);
        Bit_T tt = SV_TO_BIT_T(Bit_T, t, UNDEF_ERROR);
        RETVAL = (IV)Bit_lt(ss, tt);
#line 636 "Set.c"
	TARGi((IV)RETVAL, 1);
	ST(0) = TARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bit__Set_Bit_diff); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_Bit_diff)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "s, t");
    {
	SV *	RETVAL;
	SV *	s = ST(0)
;
	SV *	t = ST(1)
;
#line 188 "./Set_procedural.xs"
        Bit_T ss = SV_TO_BIT_T(Bit_T, s, UNDEF_ERROR);
        Bit_T tt = SV_TO_BIT_T(Bit_T, t, UNDEF_ERROR);
        Bit_T rv = Bit_diff(ss, tt);
        RETVAL = newSVuv(PTR2UV(rv));
#line 661 "Set.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bit__Set_Bit_inter); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_Bit_inter)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "s, t");
    {
	SV *	RETVAL;
	SV *	s = ST(0)
;
	SV *	t = ST(1)
;
#line 198 "./Set_procedural.xs"
        Bit_T ss = SV_TO_BIT_T(Bit_T, s, UNDEF_ERROR);
        Bit_T tt = SV_TO_BIT_T(Bit_T, t, UNDEF_ERROR);
        Bit_T rv = Bit_inter(ss, tt);
        RETVAL = newSVuv(PTR2UV(rv));
#line 686 "Set.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bit__Set_Bit_minus); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_Bit_minus)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "s, t");
    {
	SV *	RETVAL;
	SV *	s = ST(0)
;
	SV *	t = ST(1)
;
#line 208 "./Set_procedural.xs"
        Bit_T ss = SV_TO_BIT_T(Bit_T, s, UNDEF_ERROR);
        Bit_T tt = SV_TO_BIT_T(Bit_T, t, UNDEF_ERROR);
        Bit_T rv = Bit_minus(ss, tt);
        RETVAL = newSVuv(PTR2UV(rv));
#line 711 "Set.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bit__Set_Bit_union); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_Bit_union)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "s, t");
    {
	SV *	RETVAL;
	SV *	s = ST(0)
;
	SV *	t = ST(1)
;
#line 218 "./Set_procedural.xs"
        Bit_T ss = SV_TO_BIT_T(Bit_T, s, UNDEF_ERROR);
        Bit_T tt = SV_TO_BIT_T(Bit_T, t, UNDEF_ERROR);
        Bit_T rv = Bit_union(ss, tt);
        RETVAL = newSVuv(PTR2UV(rv));
#line 736 "Set.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bit__Set_Bit_diff_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_Bit_diff_count)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "s, t");
    {
	IV	RETVAL;
	dXSTARG;
	SV *	s = ST(0)
;
	SV *	t = ST(1)
;
#line 228 "./Set_procedural.xs"
        Bit_T ss = SV_TO_BIT_T(Bit_T, s, UNDEF_ERROR);
        Bit_T tt = SV_TO_BIT_T(Bit_T, t, UNDEF_ERROR);
        RETVAL = (IV)Bit_diff_count(ss, tt);
#line 761 "Set.c"
	TARGi((IV)RETVAL, 1);
	ST(0) = TARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bit__Set_Bit_inter_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_Bit_inter_count)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "s, t");
    {
	IV	RETVAL;
	dXSTARG;
	SV *	s = ST(0)
;
	SV *	t = ST(1)
;
#line 237 "./Set_procedural.xs"
        Bit_T ss = SV_TO_BIT_T(Bit_T, s, UNDEF_ERROR);
        Bit_T tt = SV_TO_BIT_T(Bit_T, t, UNDEF_ERROR);
        RETVAL = (IV)Bit_inter_count(ss, tt);
#line 786 "Set.c"
	TARGi((IV)RETVAL, 1);
	ST(0) = TARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bit__Set_Bit_minus_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_Bit_minus_count)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "s, t");
    {
	IV	RETVAL;
	dXSTARG;
	SV *	s = ST(0)
;
	SV *	t = ST(1)
;
#line 246 "./Set_procedural.xs"
        Bit_T ss = SV_TO_BIT_T(Bit_T, s, UNDEF_ERROR);
        Bit_T tt = SV_TO_BIT_T(Bit_T, t, UNDEF_ERROR);
        RETVAL = (IV)Bit_minus_count(ss, tt);
#line 811 "Set.c"
	TARGi((IV)RETVAL, 1);
	ST(0) = TARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bit__Set_Bit_union_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_Bit_union_count)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "s, t");
    {
	IV	RETVAL;
	dXSTARG;
	SV *	s = ST(0)
;
	SV *	t = ST(1)
;
#line 255 "./Set_procedural.xs"
        Bit_T ss = SV_TO_BIT_T(Bit_T, s, UNDEF_ERROR);
        Bit_T tt = SV_TO_BIT_T(Bit_T, t, UNDEF_ERROR);
        RETVAL = (IV)Bit_union_count(ss, tt);
#line 836 "Set.c"
	TARGi((IV)RETVAL, 1);
	ST(0) = TARG;
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'Set.xs' from 'Set_procedural.xs' */


XS_EUPXS(XS_Bit__Set_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_new)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "class, length");
    {
	SV *	RETVAL;
	char *	class = (char *)SvPV_nolen(ST(0))
;
	IV	length = (IV)SvIV(ST(1))
;
#line 16 "Set.xs"
      Bit_T obj = Bit_new(length);
      ST(0)  = sv_newmortal();
      sv_setiv(newSVrv(ST(0), class), PTR2IV(obj));
#line 863 "Set.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bit__Set_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "obj");
    {
	Bit_T	obj;

	if (!SvROK(ST(0)) || !sv_isobject(ST(0)) || !sv_derived_from(ST(0), "Bit::Set"))
		croak("expected a Bit::Set object");
	{
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		obj = INT2PTR(Bit_T, tmp);
	}
;
#line 23 "Set.xs"
      Bit_free(&obj);
#line 887 "Set.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bit__Set_load); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_load)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "class, length, buffer");
    {
	SV *	RETVAL;
	char *	class = (char *)SvPV_nolen(ST(0))
;
	IV	length = (IV)SvIV(ST(1))
;
	char *	buffer = (char *)SvPV_nolen(ST(2))
;
#line 28 "Set.xs"
      Bit_T obj = Bit_load(length,(void *)buffer);
      ST(0)  = sv_newmortal();
      sv_setiv(newSVrv(ST(0), class), PTR2IV(obj));
#line 911 "Set.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bit__Set_extract); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_extract)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "obj, buffer");
    {
	SV *	RETVAL;
	Bit_T	obj;
	char *	buffer = (char *)SvPV_nolen(ST(1))
;

	if (!SvROK(ST(0)) || !sv_isobject(ST(0)) || !sv_derived_from(ST(0), "Bit::Set"))
		croak("expected a Bit::Set object");
	{
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		obj = INT2PTR(Bit_T, tmp);
	}
;
#line 35 "Set.xs"
      IV rv = Bit_extract(obj,(void *)buffer);
      ST(0) = sv_newmortal();
      sv_setiv(ST(0), rv);
#line 940 "Set.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bit__Set_buffer_size); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_buffer_size)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "class, length");
    {
	SV *	RETVAL;
	char *	class = (char *)SvPV_nolen(ST(0))
;
	IV	length = (IV)SvIV(ST(1))
;
#line 42 "Set.xs"
      IV rv = Bit_buffer_size(length);
      ST(0) = sv_newmortal();
      sv_setiv(ST(0), rv);
#line 962 "Set.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bit__Set_length); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_length)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "obj");
    {
	SV *	RETVAL;
	Bit_T	obj;

	if (!SvROK(ST(0)) || !sv_isobject(ST(0)) || !sv_derived_from(ST(0), "Bit::Set"))
		croak("expected a Bit::Set object");
	{
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		obj = INT2PTR(Bit_T, tmp);
	}
;
#line 49 "Set.xs"
      IV rv = Bit_length(obj);
      ST(0) = sv_newmortal();
      sv_setiv(ST(0), rv);
#line 989 "Set.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bit__Set_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "obj");
    {
	SV *	RETVAL;
	Bit_T	obj;

	if (!SvROK(ST(0)) || !sv_isobject(ST(0)) || !sv_derived_from(ST(0), "Bit::Set"))
		croak("expected a Bit::Set object");
	{
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		obj = INT2PTR(Bit_T, tmp);
	}
;
#line 56 "Set.xs"
      IV rv = Bit_count(obj);
      ST(0) = sv_newmortal();
      sv_setiv(ST(0), rv);
#line 1016 "Set.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bit__Set_aset); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_aset)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "obj, indices");
    {
	Bit_T	obj;
	INTEGER_ARRAY_REF	indices;

	if (!SvROK(ST(0)) || !sv_isobject(ST(0)) || !sv_derived_from(ST(0), "Bit::Set"))
		croak("expected a Bit::Set object");
	{
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		obj = INT2PTR(Bit_T, tmp);
	}
;

	if (!SvOK(ST(1)) || !SvROK(ST(1)))
		croak(UNDEF_NON_REF_ARRAY_ERROR);
	if (SvTYPE(SvRV(ST(1))) != SVt_PVAV)
		croak("indices should be an array reference");
	indices = ST(1)
;
#line 63 "Set.xs"
      AV *av = (AV *)SvRV(indices);
      int n = av_len(av) + 1;
  ALLOC_ARRAY_IN_STACK_OR_HEAP(idx,int,n);
      FILL_INT_ARRAY_FROM_AV(av, idx, n);

      Bit_aset(obj, idx, n);
      FREE_ARRAY_IN_STACK_OR_HEAP(idx);
#line 1054 "Set.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bit__Set_bset); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_bset)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "obj, index");
    {
	Bit_T	obj;
	IV	index = (IV)SvIV(ST(1))
;

	if (!SvROK(ST(0)) || !sv_isobject(ST(0)) || !sv_derived_from(ST(0), "Bit::Set"))
		croak("expected a Bit::Set object");
	{
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		obj = INT2PTR(Bit_T, tmp);
	}
;
#line 75 "Set.xs"
      Bit_bset(obj, index);
#line 1080 "Set.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bit__Set_aclear); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_aclear)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "obj, indices");
    {
	Bit_T	obj;
	INTEGER_ARRAY_REF	indices;

	if (!SvROK(ST(0)) || !sv_isobject(ST(0)) || !sv_derived_from(ST(0), "Bit::Set"))
		croak("expected a Bit::Set object");
	{
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		obj = INT2PTR(Bit_T, tmp);
	}
;

	if (!SvOK(ST(1)) || !SvROK(ST(1)))
		croak(UNDEF_NON_REF_ARRAY_ERROR);
	if (SvTYPE(SvRV(ST(1))) != SVt_PVAV)
		croak("indices should be an array reference");
	indices = ST(1)
;
#line 80 "Set.xs"
      AV *av = (AV *)SvRV(indices);
      int n = av_len(av) + 1;
  ALLOC_ARRAY_IN_STACK_OR_HEAP(idx,int,n);
      FILL_INT_ARRAY_FROM_AV(av, idx, n);

      Bit_aclear(obj, idx, n);

      FREE_ARRAY_IN_STACK_OR_HEAP(idx);
#line 1119 "Set.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bit__Set_bclear); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_bclear)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "obj, index");
    {
	Bit_T	obj;
	IV	index = (IV)SvIV(ST(1))
;

	if (!SvROK(ST(0)) || !sv_isobject(ST(0)) || !sv_derived_from(ST(0), "Bit::Set"))
		croak("expected a Bit::Set object");
	{
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		obj = INT2PTR(Bit_T, tmp);
	}
;
#line 92 "Set.xs"
      Bit_bclear(obj, index);
#line 1145 "Set.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bit__Set_clear); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_clear)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "obj, lo, hi");
    {
	Bit_T	obj;
	IV	lo = (IV)SvIV(ST(1))
;
	IV	hi = (IV)SvIV(ST(2))
;

	if (!SvROK(ST(0)) || !sv_isobject(ST(0)) || !sv_derived_from(ST(0), "Bit::Set"))
		croak("expected a Bit::Set object");
	{
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		obj = INT2PTR(Bit_T, tmp);
	}
;
#line 97 "Set.xs"
      Bit_clear(obj, lo, hi);
#line 1173 "Set.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bit__Set_get); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_get)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "obj, index");
    {
	SV *	RETVAL;
	Bit_T	obj;
	IV	index = (IV)SvIV(ST(1))
;

	if (!SvROK(ST(0)) || !sv_isobject(ST(0)) || !sv_derived_from(ST(0), "Bit::Set"))
		croak("expected a Bit::Set object");
	{
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		obj = INT2PTR(Bit_T, tmp);
	}
;
#line 102 "Set.xs"
      IV rv = Bit_get(obj, index);
      ST(0) = sv_newmortal();
      sv_setiv(ST(0), rv);
#line 1202 "Set.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bit__Set_not); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_not)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "obj, lo, hi");
    {
	Bit_T	obj;
	IV	lo = (IV)SvIV(ST(1))
;
	IV	hi = (IV)SvIV(ST(2))
;

	if (!SvROK(ST(0)) || !sv_isobject(ST(0)) || !sv_derived_from(ST(0), "Bit::Set"))
		croak("expected a Bit::Set object");
	{
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		obj = INT2PTR(Bit_T, tmp);
	}
;
#line 109 "Set.xs"
      Bit_not(obj, lo, hi);
#line 1230 "Set.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bit__Set_put); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_put)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "obj, index, bit");
    {
	SV *	RETVAL;
	Bit_T	obj;
	IV	index = (IV)SvIV(ST(1))
;
	IV	bit = (IV)SvIV(ST(2))
;

	if (!SvROK(ST(0)) || !sv_isobject(ST(0)) || !sv_derived_from(ST(0), "Bit::Set"))
		croak("expected a Bit::Set object");
	{
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		obj = INT2PTR(Bit_T, tmp);
	}
;
#line 114 "Set.xs"
      IV rv = Bit_put(obj, index, bit);
      ST(0) = sv_newmortal();
      sv_setiv(ST(0), rv);
#line 1261 "Set.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bit__Set_set); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_set)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "obj, lo, hi");
    {
	Bit_T	obj;
	IV	lo = (IV)SvIV(ST(1))
;
	IV	hi = (IV)SvIV(ST(2))
;

	if (!SvROK(ST(0)) || !sv_isobject(ST(0)) || !sv_derived_from(ST(0), "Bit::Set"))
		croak("expected a Bit::Set object");
	{
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		obj = INT2PTR(Bit_T, tmp);
	}
;
#line 121 "Set.xs"
      Bit_set(obj, lo, hi);
#line 1289 "Set.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bit__Set_eq); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_eq)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "obj, other");
    {
	SV *	RETVAL;
	Bit_T	obj;
	Bit_T	other;

	if (!SvROK(ST(0)) || !sv_isobject(ST(0)) || !sv_derived_from(ST(0), "Bit::Set"))
		croak("expected a Bit::Set object");
	{
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		obj = INT2PTR(Bit_T, tmp);
	}
;

	if (!SvROK(ST(1)) || !sv_isobject(ST(1)) || !sv_derived_from(ST(1), "Bit::Set"))
		croak("expected a Bit::Set object");
	{
		IV tmp = SvIV((SV*)SvRV(ST(1)));
		other = INT2PTR(Bit_T, tmp);
	}
;
#line 126 "Set.xs"
      IV rv = Bit_eq(obj, other);
      ST(0) = sv_newmortal();
      sv_setiv(ST(0), rv);
#line 1325 "Set.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bit__Set_leq); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_leq)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "obj, other");
    {
	SV *	RETVAL;
	Bit_T	obj;
	Bit_T	other;

	if (!SvROK(ST(0)) || !sv_isobject(ST(0)) || !sv_derived_from(ST(0), "Bit::Set"))
		croak("expected a Bit::Set object");
	{
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		obj = INT2PTR(Bit_T, tmp);
	}
;

	if (!SvROK(ST(1)) || !sv_isobject(ST(1)) || !sv_derived_from(ST(1), "Bit::Set"))
		croak("expected a Bit::Set object");
	{
		IV tmp = SvIV((SV*)SvRV(ST(1)));
		other = INT2PTR(Bit_T, tmp);
	}
;
#line 133 "Set.xs"
      IV rv = Bit_leq(obj, other);
      ST(0) = sv_newmortal();
      sv_setiv(ST(0), rv);
#line 1361 "Set.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bit__Set_lt); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_lt)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "obj, other");
    {
	SV *	RETVAL;
	Bit_T	obj;
	Bit_T	other;

	if (!SvROK(ST(0)) || !sv_isobject(ST(0)) || !sv_derived_from(ST(0), "Bit::Set"))
		croak("expected a Bit::Set object");
	{
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		obj = INT2PTR(Bit_T, tmp);
	}
;

	if (!SvROK(ST(1)) || !sv_isobject(ST(1)) || !sv_derived_from(ST(1), "Bit::Set"))
		croak("expected a Bit::Set object");
	{
		IV tmp = SvIV((SV*)SvRV(ST(1)));
		other = INT2PTR(Bit_T, tmp);
	}
;
#line 140 "Set.xs"
      IV rv = Bit_lt(obj, other);
      ST(0) = sv_newmortal();
      sv_setiv(ST(0), rv);
#line 1397 "Set.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bit__Set_diff); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_diff)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "obj, other");
    {
	SV *	RETVAL;
	Bit_T	obj;
	Bit_T	other;

	if (!SvROK(ST(0)) || !sv_isobject(ST(0)) || !sv_derived_from(ST(0), "Bit::Set"))
		croak("expected a Bit::Set object");
	{
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		obj = INT2PTR(Bit_T, tmp);
	}
;

	if (!SvROK(ST(1)) || !sv_isobject(ST(1)) || !sv_derived_from(ST(1), "Bit::Set"))
		croak("expected a Bit::Set object");
	{
		IV tmp = SvIV((SV*)SvRV(ST(1)));
		other = INT2PTR(Bit_T, tmp);
	}
;
#line 147 "Set.xs"
      Bit_T rv = Bit_diff(obj, other);
      ST(0)  = sv_newmortal();
      sv_setiv(newSVrv(ST(0), "Bit::Set"), PTR2IV(rv));
#line 1433 "Set.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bit__Set_inter); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_inter)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "obj, other");
    {
	SV *	RETVAL;
	Bit_T	obj;
	Bit_T	other;

	if (!SvROK(ST(0)) || !sv_isobject(ST(0)) || !sv_derived_from(ST(0), "Bit::Set"))
		croak("expected a Bit::Set object");
	{
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		obj = INT2PTR(Bit_T, tmp);
	}
;

	if (!SvROK(ST(1)) || !sv_isobject(ST(1)) || !sv_derived_from(ST(1), "Bit::Set"))
		croak("expected a Bit::Set object");
	{
		IV tmp = SvIV((SV*)SvRV(ST(1)));
		other = INT2PTR(Bit_T, tmp);
	}
;
#line 154 "Set.xs"
      Bit_T rv = Bit_inter(obj, other);
      ST(0)  = sv_newmortal();
      sv_setiv(newSVrv(ST(0), "Bit::Set"), PTR2IV(rv));
#line 1469 "Set.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bit__Set_minus); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_minus)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "obj, other");
    {
	SV *	RETVAL;
	Bit_T	obj;
	Bit_T	other;

	if (!SvROK(ST(0)) || !sv_isobject(ST(0)) || !sv_derived_from(ST(0), "Bit::Set"))
		croak("expected a Bit::Set object");
	{
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		obj = INT2PTR(Bit_T, tmp);
	}
;

	if (!SvROK(ST(1)) || !sv_isobject(ST(1)) || !sv_derived_from(ST(1), "Bit::Set"))
		croak("expected a Bit::Set object");
	{
		IV tmp = SvIV((SV*)SvRV(ST(1)));
		other = INT2PTR(Bit_T, tmp);
	}
;
#line 161 "Set.xs"
      Bit_T rv = Bit_minus(obj, other);
      ST(0)  = sv_newmortal();
      sv_setiv(newSVrv(ST(0), "Bit::Set"), PTR2IV(rv));
#line 1505 "Set.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bit__Set_union); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_union)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "obj, other");
    {
	SV *	RETVAL;
	Bit_T	obj;
	Bit_T	other;

	if (!SvROK(ST(0)) || !sv_isobject(ST(0)) || !sv_derived_from(ST(0), "Bit::Set"))
		croak("expected a Bit::Set object");
	{
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		obj = INT2PTR(Bit_T, tmp);
	}
;

	if (!SvROK(ST(1)) || !sv_isobject(ST(1)) || !sv_derived_from(ST(1), "Bit::Set"))
		croak("expected a Bit::Set object");
	{
		IV tmp = SvIV((SV*)SvRV(ST(1)));
		other = INT2PTR(Bit_T, tmp);
	}
;
#line 168 "Set.xs"
      Bit_T rv = Bit_union(obj, other);
      ST(0)  = sv_newmortal();
      sv_setiv(newSVrv(ST(0), "Bit::Set"), PTR2IV(rv));
#line 1541 "Set.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bit__Set_diff_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_diff_count)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "obj, other");
    {
	SV *	RETVAL;
	Bit_T	obj;
	Bit_T	other;

	if (!SvROK(ST(0)) || !sv_isobject(ST(0)) || !sv_derived_from(ST(0), "Bit::Set"))
		croak("expected a Bit::Set object");
	{
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		obj = INT2PTR(Bit_T, tmp);
	}
;

	if (!SvROK(ST(1)) || !sv_isobject(ST(1)) || !sv_derived_from(ST(1), "Bit::Set"))
		croak("expected a Bit::Set object");
	{
		IV tmp = SvIV((SV*)SvRV(ST(1)));
		other = INT2PTR(Bit_T, tmp);
	}
;
#line 175 "Set.xs"
      IV rv = Bit_diff_count(obj, other);
      ST(0) = sv_newmortal();
      sv_setiv(ST(0), rv);
#line 1577 "Set.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bit__Set_inter_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_inter_count)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "obj, other");
    {
	SV *	RETVAL;
	Bit_T	obj;
	Bit_T	other;

	if (!SvROK(ST(0)) || !sv_isobject(ST(0)) || !sv_derived_from(ST(0), "Bit::Set"))
		croak("expected a Bit::Set object");
	{
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		obj = INT2PTR(Bit_T, tmp);
	}
;

	if (!SvROK(ST(1)) || !sv_isobject(ST(1)) || !sv_derived_from(ST(1), "Bit::Set"))
		croak("expected a Bit::Set object");
	{
		IV tmp = SvIV((SV*)SvRV(ST(1)));
		other = INT2PTR(Bit_T, tmp);
	}
;
#line 182 "Set.xs"
      IV rv = Bit_inter_count(obj, other);
      ST(0) = sv_newmortal();
      sv_setiv(ST(0), rv);
#line 1613 "Set.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bit__Set_minus_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_minus_count)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "obj, other");
    {
	SV *	RETVAL;
	Bit_T	obj;
	Bit_T	other;

	if (!SvROK(ST(0)) || !sv_isobject(ST(0)) || !sv_derived_from(ST(0), "Bit::Set"))
		croak("expected a Bit::Set object");
	{
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		obj = INT2PTR(Bit_T, tmp);
	}
;

	if (!SvROK(ST(1)) || !sv_isobject(ST(1)) || !sv_derived_from(ST(1), "Bit::Set"))
		croak("expected a Bit::Set object");
	{
		IV tmp = SvIV((SV*)SvRV(ST(1)));
		other = INT2PTR(Bit_T, tmp);
	}
;
#line 189 "Set.xs"
      IV rv = Bit_minus_count(obj, other);
      ST(0) = sv_newmortal();
      sv_setiv(ST(0), rv);
#line 1649 "Set.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bit__Set_union_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bit__Set_union_count)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "obj, other");
    {
	SV *	RETVAL;
	Bit_T	obj;
	Bit_T	other;

	if (!SvROK(ST(0)) || !sv_isobject(ST(0)) || !sv_derived_from(ST(0), "Bit::Set"))
		croak("expected a Bit::Set object");
	{
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		obj = INT2PTR(Bit_T, tmp);
	}
;

	if (!SvROK(ST(1)) || !sv_isobject(ST(1)) || !sv_derived_from(ST(1), "Bit::Set"))
		croak("expected a Bit::Set object");
	{
		IV tmp = SvIV((SV*)SvRV(ST(1)));
		other = INT2PTR(Bit_T, tmp);
	}
;
#line 196 "Set.xs"
      IV rv = Bit_union_count(obj, other);
      ST(0) = sv_newmortal();
      sv_setiv(ST(0), rv);
#line 1685 "Set.c"
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C" {
#endif
XS_EXTERNAL(boot_Bit__Set); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Bit__Set)
{
#if PERL_VERSION_LE(5, 21, 5)
    dVAR; dXSARGS;
#else
    dVAR; dXSBOOTARGSXSAPIVERCHK;
#endif
#if PERL_VERSION_LE(5, 8, 999) /* PERL_VERSION_LT is 5.33+ */
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(file);

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#if PERL_VERSION_LE(5, 21, 5)
    XS_VERSION_BOOTCHECK;
#  ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#  endif
#endif

        newXS_deffile("Bit::Set::Bit_new", XS_Bit__Set_Bit_new);
        newXS_deffile("Bit::Set::Bit_free", XS_Bit__Set_Bit_free);
        newXS_deffile("Bit::Set::Bit_load", XS_Bit__Set_Bit_load);
        newXS_deffile("Bit::Set::Bit_extract", XS_Bit__Set_Bit_extract);
        newXS_deffile("Bit::Set::Bit_buffer_size", XS_Bit__Set_Bit_buffer_size);
        newXS_deffile("Bit::Set::Bit_length", XS_Bit__Set_Bit_length);
        newXS_deffile("Bit::Set::Bit_count", XS_Bit__Set_Bit_count);
        newXS_deffile("Bit::Set::Bit_aset", XS_Bit__Set_Bit_aset);
        newXS_deffile("Bit::Set::Bit_bset", XS_Bit__Set_Bit_bset);
        newXS_deffile("Bit::Set::Bit_aclear", XS_Bit__Set_Bit_aclear);
        newXS_deffile("Bit::Set::Bit_bclear", XS_Bit__Set_Bit_bclear);
        newXS_deffile("Bit::Set::Bit_clear", XS_Bit__Set_Bit_clear);
        newXS_deffile("Bit::Set::Bit_get", XS_Bit__Set_Bit_get);
        newXS_deffile("Bit::Set::Bit_not", XS_Bit__Set_Bit_not);
        newXS_deffile("Bit::Set::Bit_put", XS_Bit__Set_Bit_put);
        newXS_deffile("Bit::Set::Bit_set", XS_Bit__Set_Bit_set);
        newXS_deffile("Bit::Set::Bit_eq", XS_Bit__Set_Bit_eq);
        newXS_deffile("Bit::Set::Bit_leq", XS_Bit__Set_Bit_leq);
        newXS_deffile("Bit::Set::Bit_lt", XS_Bit__Set_Bit_lt);
        newXS_deffile("Bit::Set::Bit_diff", XS_Bit__Set_Bit_diff);
        newXS_deffile("Bit::Set::Bit_inter", XS_Bit__Set_Bit_inter);
        newXS_deffile("Bit::Set::Bit_minus", XS_Bit__Set_Bit_minus);
        newXS_deffile("Bit::Set::Bit_union", XS_Bit__Set_Bit_union);
        newXS_deffile("Bit::Set::Bit_diff_count", XS_Bit__Set_Bit_diff_count);
        newXS_deffile("Bit::Set::Bit_inter_count", XS_Bit__Set_Bit_inter_count);
        newXS_deffile("Bit::Set::Bit_minus_count", XS_Bit__Set_Bit_minus_count);
        newXS_deffile("Bit::Set::Bit_union_count", XS_Bit__Set_Bit_union_count);
        newXS_deffile("Bit::Set::new", XS_Bit__Set_new);
        newXS_deffile("Bit::Set::DESTROY", XS_Bit__Set_DESTROY);
        newXS_deffile("Bit::Set::load", XS_Bit__Set_load);
        newXS_deffile("Bit::Set::extract", XS_Bit__Set_extract);
        newXS_deffile("Bit::Set::buffer_size", XS_Bit__Set_buffer_size);
        newXS_deffile("Bit::Set::length", XS_Bit__Set_length);
        newXS_deffile("Bit::Set::count", XS_Bit__Set_count);
        newXS_deffile("Bit::Set::aset", XS_Bit__Set_aset);
        newXS_deffile("Bit::Set::bset", XS_Bit__Set_bset);
        newXS_deffile("Bit::Set::aclear", XS_Bit__Set_aclear);
        newXS_deffile("Bit::Set::bclear", XS_Bit__Set_bclear);
        newXS_deffile("Bit::Set::clear", XS_Bit__Set_clear);
        newXS_deffile("Bit::Set::get", XS_Bit__Set_get);
        newXS_deffile("Bit::Set::not", XS_Bit__Set_not);
        newXS_deffile("Bit::Set::put", XS_Bit__Set_put);
        newXS_deffile("Bit::Set::set", XS_Bit__Set_set);
        newXS_deffile("Bit::Set::eq", XS_Bit__Set_eq);
        newXS_deffile("Bit::Set::leq", XS_Bit__Set_leq);
        newXS_deffile("Bit::Set::lt", XS_Bit__Set_lt);
        newXS_deffile("Bit::Set::diff", XS_Bit__Set_diff);
        newXS_deffile("Bit::Set::inter", XS_Bit__Set_inter);
        newXS_deffile("Bit::Set::minus", XS_Bit__Set_minus);
        newXS_deffile("Bit::Set::union", XS_Bit__Set_union);
        newXS_deffile("Bit::Set::diff_count", XS_Bit__Set_diff_count);
        newXS_deffile("Bit::Set::inter_count", XS_Bit__Set_inter_count);
        newXS_deffile("Bit::Set::minus_count", XS_Bit__Set_minus_count);
        newXS_deffile("Bit::Set::union_count", XS_Bit__Set_union_count);
#if PERL_VERSION_LE(5, 21, 5)
#  if PERL_VERSION_GE(5, 9, 0)
    if (PL_unitcheckav)
        call_list(PL_scopestack_ix, PL_unitcheckav);
#  endif
    XSRETURN_YES;
#else
    Perl_xs_boot_epilog(aTHX_ ax);
#endif
}

#ifdef __cplusplus
}
#endif
